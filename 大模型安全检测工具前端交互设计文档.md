# 大模型安全检测工具 - 前端页面交互设计文档

## 文档信息

- **项目名称**: 大模型安全检测工具
- **文档版本**: v1.0
- **创建日期**: 2025-12-26
- **文档类型**: 前端交互设计规范

---

## 目录

1. [系统概述](#1-系统概述)
2. [前端技术架构](#2-前端技术架构)
3. [页面结构设计](#3-页面结构设计)
4. [核心页面交互设计](#4-核心页面交互设计)
5. [数据交互流程](#5-数据交互流程)
6. [状态管理设计](#6-状态管理设计)
7. [用户体验设计](#7-用户体验设计)
8. [响应式设计](#8-响应式设计)
9. [性能优化策略](#9-性能优化策略)

---

## 1. 系统概述

### 1.1 系统简介

大模型安全检测工具是一个**实时AI安全检测平台**,采用7层检测架构,为用户提供prompt注入攻击检测、jailbreak攻击防护等安全服务。

### 1.2 核心功能

- **实时检测**: WebSocket实时检测接口
- **批量检测**: REST API批量检测
- **威胁分析**: 多维度威胁分析报告
- **实时监控**: 系统性能与威胁态势监控
- **规则管理**: 检测规则配置管理

---

## 2. 前端技术架构

### 2.1 技术栈选择

```
前端框架: React 18+
状态管理: Redux Toolkit + RTK Query
路由管理: React Router v6
UI框架: Ant Design 5.x
HTTP客户端: Axios
WebSocket: Socket.io-client
图表可视化: ECharts + D3.js
构建工具: Vite
包管理器: pnpm
TypeScript: 5.x
```

### 2.2 项目目录结构

```
frontend/
├── src/
│   ├── components/          # 通用组件
│   │   ├── Layout/         # 布局组件
│   │   ├── Detection/      # 检测相关组件
│   │   ├── Dashboard/      # 仪表盘组件
│   │   ├── Monitor/        # 监控组件
│   │   └── Common/         # 公共组件
│   ├── pages/              # 页面组件
│   │   ├── Dashboard/      # 仪表盘页面
│   │   ├── Detection/      # 检测页面
│   │   ├── Analysis/       # 分析页面
│   │   ├── Monitor/        # 监控页面
│   │   └── Settings/       # 设置页面
│   ├── hooks/              # 自定义Hooks
│   ├── services/           # API服务
│   ├── store/              # 状态管理
│   ├── utils/              # 工具函数
│   ├── types/              # TypeScript类型
│   └── styles/             # 全局样式
├── public/
│   └── index.html
└── package.json
```

---

## 3. 页面结构设计

### 3.1 整体布局

系统采用**经典后台管理布局**:

```
┌─────────────────────────────────────────────────┐
│              顶部导航栏 (Header)                  │
├────────┬────────────────────────────────────────┤
│        │                                         │
│        │                                         │
│ 侧边   │           主内容区域                  │
│ 导航   │           (Content Area)              │
│        │                                         │
│ (Menu) │                                         │
└────────┴────────────────────────────────────────┘
```

### 3.2 导航结构

```typescript
// 菜单配置结构
interface MenuItem {
  key: string;           // 唯一标识
  label: string;         // 显示文本
  icon: ReactNode;      // 图标
  path: string;         // 路由路径
  children?: MenuItem[]; // 子菜单
}

const menuItems: MenuItem[] = [
  {
    key: 'dashboard',
    label: '仪表盘',
    icon: <DashboardOutlined />,
    path: '/dashboard'
  },
  {
    key: 'detection',
    label: '安全检测',
    icon: <SecurityScanOutlined />,
    children: [
      {
        key: 'realtime',
        label: '实时检测',
        path: '/detection/realtime'
      },
      {
        key: 'batch',
        label: '批量检测',
        path: '/detection/batch'
      }
    ]
  },
  {
    key: 'analysis',
    label: '威胁分析',
    icon: <AnalysisOutlined />,
    path: '/analysis'
  },
  {
    key: 'monitor',
    label: '实时监控',
    icon: <MonitorOutlined />,
    path: '/monitor'
  },
  {
    key: 'settings',
    label: '系统设置',
    icon: <SettingOutlined />,
    path: '/settings'
  }
];
```

---

## 4. 核心页面交互设计

### 4.1 实时检测页面

#### 4.1.1 页面布局

```tsx
// pages/Detection/Realtime/index.tsx
function RealtimeDetectionPage() {
  return (
    <div className="realtime-detection-page">
      <Card title="实时安全检测" bordered={false}>
        {/* 输入区域 */}
        <div className="detection-input-section">
          <TextArea
            placeholder="请输入要检测的文本内容..."
            rows={6}
            maxLength={10000}
            showCount
          />

          {/* 检测选项 */}
          <Space className="detection-options">
            <Checkbox>启用上下文分析</Checkbox>
            <Checkbox>启用深度检测</Checkbox>
            <Select placeholder="选择检测模型" style={{width: 200}}>
              <Option value="standard">标准模型</Option>
              <Option value="advanced">高级模型</Option>
            </Select>
          </Space>

          {/* 操作按钮 */}
          <Space className="action-buttons">
            <Button
              type="primary"
              size="large"
              icon={<ThunderboltOutlined />}
              onClick={handleStartDetection}
            >
              开始检测
            </Button>
            <Button
              size="large"
              icon={<ClearOutlined />}
              onClick={handleClear}
            >
              清空
            </Button>
          </Space>
        </div>

        {/* 实时结果展示 */}
        <div className="detection-result-section">
          <DetectionResultPanel />
        </div>
      </Card>
    </div>
  );
}
```

#### 4.1.2 交互流程

```
用户输入文本
    ↓
点击"开始检测"按钮
    ↓
前端验证
    ├─→ 验证失败 → 显示错误提示
    └─→ 验证成功
        ↓
    建立WebSocket连接
        ↓
    发送检测请求
    ↓
    显示检测中状态
    ↓
    接收实时检测结果
        ↓
    更新检测结果面板
        ↓
    显示风险评分和建议
```

#### 4.1.3 WebSocket实时通信

```typescript
// hooks/useWebSocketDetection.ts
function useWebSocketDetection() {
  const [socket, setSocket] = useState<Socket | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [detectionResult, setDetectionResult] = useState<DetectionResult | null>(null);
  const [isDetecting, setIsDetecting] = useState(false);

  useEffect(() => {
    // 建立WebSocket连接
    const socketInstance = io('ws://localhost:8000/ws/detect', {
      transports: ['websocket'],
      reconnection: true,
      reconnectionAttempts: 5,
      reconnectionDelay: 1000
    });

    socketInstance.on('connect', () => {
      setIsConnected(true);
      message.success('实时检测服务已连接');
    });

    socketInstance.on('disconnect', () => {
      setIsConnected(false);
      message.warning('实时检测服务已断开');
    });

    socketInstance.on('detection_result', (result: DetectionResult) => {
      setDetectionResult(result);
      setIsDetecting(false);

      // 根据风险等级显示不同提示
      if (result.risk_score >= 0.8) {
        message.error('检测到严重风险!');
      } else if (result.risk_score >= 0.5) {
        message.warning('检测到高风险内容');
      } else if (result.risk_score >= 0.3) {
        message.info('检测到中等风险');
      } else {
        message.success('内容安全');
      }
    });

    socketInstance.on('detection_error', (error) => {
      setIsDetecting(false);
      message.error(`检测失败: ${error.message}`);
    });

    setSocket(socketInstance);

    return () => {
      socketInstance.disconnect();
    };
  }, []);

  const startDetection = (params: DetectionRequest) => {
    if (!isConnected) {
      message.error('服务未连接,请稍后重试');
      return;
    }

    setIsDetecting(true);
    socket?.emit('start_detection', params);
  };

  return {
    socket,
    isConnected,
    isDetecting,
    detectionResult,
    startDetection
  };
}
```

#### 4.1.4 检测结果面板

```tsx
// components/Detection/ResultPanel.tsx
interface DetectionResultPanelProps {
  result: DetectionResult | null;
  isDetecting: boolean;
}

function DetectionResultPanel({ result, isDetecting }: DetectionResultPanelProps) {

  if (isDetecting) {
    return (
      <div className="detection-loading">
        <Spin size="large" tip="正在进行安全检测..." />
      </div>
    );
  }

  if (!result) {
    return (
      <Empty
        description="请输入内容并点击开始检测"
        image={Empty.PRESENTED_IMAGE_SIMPLE}
      />
    );
  }

  return (
    <div className="detection-result">
      {/* 风险评分卡片 */}
      <Card
        title="检测报告"
        extra={
          <Tag color={getRiskColor(result.risk_level)}>
            {getRiskLabel(result.risk_level)}
          </Tag>
        }
      >
        {/* 风险评分进度条 */}
        <div className="risk-score-section">
          <Progress
            type="circle"
            percent={result.risk_score * 100}
            strokeColor={getRiskColor(result.risk_level)}
            format={percent => `${percent}%`}
          />
        </div>

        {/* 详细检测结果 */}
        <Descriptions bordered column={2}>
          <Descriptions.Item label="威胁类别">
            {result.threat_category}
          </Descriptions.Item>
          <Descriptions.Item label="攻击向量">
            {result.detection_details.attack_vector}
          </Descriptions.Item>
          <Descriptions.Item label="置信度">
            <Progress
              percent={result.detection_details.confidence * 100}
              size="small"
              strokeColor="#52c41a"
            />
          </Descriptions.Item>
          <Descriptions.Item label="处理时间">
            {result.processing_time_ms}ms
          </Descriptions.Item>
        </Descriptions>

        {/* 匹配的模式 */}
        {result.detection_details.matched_patterns?.length > 0 && (
          <Alert
            message="检测到以下可疑模式"
            description={
              <ul>
                {result.detection_details.matched_patterns.map((pattern, index) => (
                  <li key={index}>{pattern}</li>
                ))}
              </ul>
            }
            type="warning"
            showIcon
          />
        )}

        {/* 处理建议 */}
        <div className="recommendation-section">
          <Title level={5}>处理建议</Title>
          <Paragraph>
            <Text type={result.recommendation === 'block' ? 'danger' : 'success'}>
              {result.recommendation === 'block' ? '⛔ 建议拦截此内容' : '✅ 内容安全,可以放行'}
            </Text>
          </Paragraph>
        </div>
      </Card>

      {/* 检测详情时间线 */}
      <Card title="检测流程" style={{marginTop: 16}}>
        <Timeline>
          <Timeline.Item color="green">输入预处理</Timeline.Item>
          <Timeline.Item color="green">静态检测</Timeline.Item>
          <Timeline.Item color="green">语义分析</Timeline.Item>
          <Timeline.Item color="green">行为分析</Timeline.Item>
          <Timeline.Item color="green">上下文分析</Timeline.Item>
          <Timeline.Item color="green">风险评估</Timeline.Item>
          <Timeline.Item color="green">决策处理</Timeline.Item>
        </Timeline>
      </Card>
    </div>
  );
}
```

### 4.2 批量检测页面

#### 4.2.1 页面布局

```tsx
// pages/Detection/Batch/index.tsx
function BatchDetectionPage() {
  const [fileList, setFileList] = useState<UploadFile[]>([]);
  const [detectionResults, setDetectionResults] = useState<BatchDetectionResult[]>([]);
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState(0);

  const uploadProps = {
    name: 'file',
    multiple: true,
    accept: '.txt,.json,.csv',
    beforeUpload: (file: File) => {
      // 验证文件大小 (最大10MB)
      const isValidSize = file.size / 1024 / 1024 < 10;
      if (!isValidSize) {
        message.error('文件大小不能超过10MB');
      }
      return isValidSize;
    },
    onChange: (info: UploadChangeParam) => {
      setFileList(info.fileList);
    },
    onDrop: (e: React.DragEvent) => {
      console.log('Dropped files', e.dataTransfer.files);
    }
  };

  const handleBatchDetection = async () => {
    if (fileList.length === 0) {
      message.warning('请先上传要检测的文件');
      return;
    }

    setIsProcessing(true);
    setProgress(0);

    try {
      const formData = new FormData();
      fileList.forEach((file) => {
        formData.append('files', file.originFileObj);
      });

      const response = await axios.post('/api/v1/detection/batch', formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        onUploadProgress: (progressEvent) => {
          const percentCompleted = Math.round(
            (progressEvent.loaded * 100) / (progressEvent.total || 1)
          );
          setProgress(percentCompleted);
        }
      });

      setDetectionResults(response.data.results);
      message.success(`批量检测完成,共处理 ${fileList.length} 个文件`);
    } catch (error) {
      message.error('批量检测失败');
    } finally {
      setIsProcessing(false);
      setProgress(0);
    }
  };

  return (
    <div className="batch-detection-page">
      <Row gutter={16}>
        {/* 上传区域 */}
        <Col span={24}>
          <Card title="文件上传" bordered={false}>
            <Dragger {...uploadProps}>
              <p className="ant-upload-drag-icon">
                <InboxOutlined />
              </p>
              <p className="ant-upload-text">点击或拖拽文件到此区域上传</p>
              <p className="ant-upload-hint">
                支持批量上传,单个文件不超过10MB
              </p>
            </Dragger>

            {/* 文件列表 */}
            {fileList.length > 0 && (
              <div className="file-list-section">
                <Divider />
                <List
                  dataSource={fileList}
                  renderItem={(file) => (
                    <List.Item
                      actions={[
                        <Button
                          type="link"
                          danger
                          onClick={() => handleRemoveFile(file)}
                        >
                          删除
                        </Button>
                      ]}
                    >
                      <List.Item.Meta
                        avatar={<FileTextOutlined />}
                        title={file.name}
                        description={`${(file.originFileObj.size / 1024).toFixed(2)} KB`}
                      />
                    </List.Item>
                  )}
                />
              </div>
            )}

            {/* 开始检测按钮 */}
            {fileList.length > 0 && (
              <div className="action-section">
                <Space>
                  <Button
                    type="primary"
                    size="large"
                    icon={<ThunderboltOutlined />}
                    loading={isProcessing}
                    onClick={handleBatchDetection}
                  >
                    开始批量检测
                  </Button>
                  <Button
                    size="large"
                    icon={<DeleteOutlined />}
                    onClick={handleClearAll}
                  >
                    清空列表
                  </Button>
                </Space>

                {/* 进度条 */}
                {isProcessing && (
                  <div style={{width: '100%', marginTop: 16}}>
                    <Progress percent={progress} />
                  </div>
                )}
              </div>
            )}
          </Card>
        </Col>

        {/* 检测结果 */}
        {detectionResults.length > 0 && (
          <Col span={24}>
            <Card title="检测结果" bordered={false} style={{marginTop: 16}}>
              <Table
                dataSource={detectionResults}
                columns={batchDetectionColumns}
                rowKey="request_id"
                pagination={{
                  pageSize: 10,
                  showTotal: (total) => `共 ${total} 条记录`
                }}
                scroll={{x: 1200}}
              />
            </Card>
          </Col>
        )}
      </Row>
    </div>
  );
}
```

#### 4.2.2 批量检测表格列定义

```typescript
// 表格列配置
const batchDetectionColumns: ColumnsType<BatchDetectionResult> = [
  {
    title: '请求ID',
    dataIndex: 'request_id',
    key: 'request_id',
    width: 200,
    ellipsis: true,
    render: (text) => (
      <Tooltip title={text}>
        <span>{text}</span>
      </Tooltip>
    )
  },
  {
    title: '风险等级',
    dataIndex: 'risk_level',
    key: 'risk_level',
    width: 120,
    filters: [
      {text: '严重', value: 'critical'},
      {text: '高风险', value: 'high'},
      {text: '中风险', value: 'medium'},
      {text: '低风险', value: 'low'}
    ],
    render: (level: string) => (
      <Tag color={getRiskColor(level)}>
        {getRiskLabel(level)}
      </Tag>
    )
  },
  {
    title: '风险评分',
    dataIndex: 'risk_score',
    key: 'risk_score',
    width: 150,
    sorter: (a, b) => a.risk_score - b.risk_score,
    render: (score: number) => (
      <Progress
        percent={score * 100}
        size="small"
        strokeColor={getRiskScoreColor(score)}
      />
    )
  },
  {
    title: '威胁类别',
    dataIndex: 'threat_category',
    key: 'threat_category',
    width: 150,
    ellipsis: true
  },
  {
    title: '处理建议',
    dataIndex: 'recommendation',
    key: 'recommendation',
    width: 120,
    render: (recommendation: string) => (
      recommendation === 'block' ? (
        <Tag color="red">拦截</Tag>
      ) : (
        <Tag color="green">通过</Tag>
      )
    )
  },
  {
    title: '处理时间',
    dataIndex: 'processing_time_ms',
    key: 'processing_time_ms',
    width: 120,
    render: (time: number) => `${time}ms`,
    sorter: (a, b) => a.processing_time_ms - b.processing_time_ms
  },
  {
    title: '操作',
    key: 'action',
    width: 150,
    fixed: 'right',
    render: (_, record) => (
      <Space>
        <Button
          type="link"
          size="small"
          icon={<EyeOutlined />}
          onClick={() => handleViewDetail(record)}
        >
          详情
        </Button>
        <Button
          type="link"
          size="small"
          icon={<DownloadOutlined />}
          onClick={() => handleExportReport(record)}
        >
          导出
        </Button>
      </Space>
    )
  }
];
```

### 4.3 仪表盘页面

#### 4.3.1 页面布局

```tsx
// pages/Dashboard/index.tsx
function DashboardPage() {
  const {data: statistics, isLoading} = useGetStatisticsQuery();
  const {data: trendData} = useGetTrendDataQuery();
  const {data: topThreats} = useGetTopThreatsQuery();

  return (
    <div className="dashboard-page">
      <Row gutter={[16, 16]}>
        {/* 统计卡片 */}
        <Col xs={24} sm={12} md={6}>
          <StatisticCard
            title="总检测次数"
            value={statistics?.total_detections}
            prefix={<SecurityScanOutlined />}
            suffix="次"
            loading={isLoading}
          />
        </Col>

        <Col xs={24} sm={12} md={6}>
          <StatisticCard
            title="威胁拦截"
            value={statistics?.blocked_threats}
            prefix={<StopOutlined />}
            suffix="次"
            valueStyle={{color: '#ff4d4f'}}
            loading={isLoading}
          />
        </Col>

        <Col xs={24} sm={12} md={6}>
          <StatisticCard
            title="平均响应时间"
            value={statistics?.avg_response_time}
            prefix={<ClockCircleOutlined />}
            suffix="ms"
            precision={2}
            loading={isLoading}
          />
        </Col>

        <Col xs={24} sm={12} md={6}>
          <StatisticCard
            title="检测准确率"
            value={statistics?.accuracy}
            prefix={<CheckCircleOutlined />}
            suffix="%"
            precision={2}
            valueStyle={{color: '#52c41a'}}
            loading={isLoading}
          />
        </Col>

        {/* 趋势图表 */}
        <Col xs={24} lg={16}>
          <Card title="检测趋势" bordered={false} loading={isLoading}>
            <TrendChart data={trendData} />
          </Card>
        </Col>

        {/* 威胁分布 */}
        <Col xs={24} lg={8}>
          <Card title="威胁类型分布" bordered={false} loading={isLoading}>
            <ThreatDistributionChart data={statistics?.threat_distribution} />
          </Card>
        </Col>

        {/* TOP威胁 */}
        <Col span={24}>
          <Card title="高频威胁TOP10" bordered={false} loading={isLoading}>
            <TopThreatsTable data={topThreats} />
          </Card>
        </Col>

        {/* 实时日志 */}
        <Col span={24}>
          <Card title="实时检测日志" bordered={false}>
            <RealtimeLogStream />
          </Card>
        </Col>
      </Row>
    </div>
  );
}
```

#### 4.3.2 趋势图表组件

```tsx
// components/Dashboard/TrendChart.tsx
function TrendChart({ data }: { data: TrendDataPoint[] }) {
  const chartRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    if (!chartRef.current || !data) return;

    const chart = echarts.init(chartRef.current);

    const option: EChartsOption = {
      tooltip: {
        trigger: 'axis',
        axisPointer: {
          type: 'cross'
        }
      },
      legend: {
        data: ['检测次数', '威胁次数', '拦截次数']
      },
      grid: {
        left: '3%',
        right: '4%',
        bottom: '3%',
        containLabel: true
      },
      xAxis: {
        type: 'category',
        boundaryGap: false,
        data: data.map(item => item.time)
      },
      yAxis: {
        type: 'value'
      },
      series: [
        {
          name: '检测次数',
          type: 'line',
          data: data.map(item => item.total_count),
          smooth: true,
          areaStyle: {
            opacity: 0.3
          }
        },
        {
          name: '威胁次数',
          type: 'line',
          data: data.map(item => item.threat_count),
          smooth: true,
          itemStyle: {
            color: '#ff4d4f'
          }
        },
        {
          name: '拦截次数',
          type: 'line',
          data: data.map(item => item.blocked_count),
          smooth: true,
          itemStyle: {
            color: '#faad14'
          }
        }
      ]
    };

    chart.setOption(option);

    const handleResize = () => {
      chart.resize();
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      chart.dispose();
    };
  }, [data]);

  return <div ref={chartRef} style={{width: '100%', height: '350px'}} />;
}
```

### 4.4 实时监控页面

#### 4.4.1 页面布局

```tsx
// pages/Monitor/index.tsx
function MonitorPage() {
  const [systemMetrics, setSystemMetrics] = useState<SystemMetrics | null>(null);
  const [detectionMetrics, setDetectionMetrics] = useState<DetectionMetrics | null>(null);

  useEffect(() => {
    // 建立WebSocket连接获取实时监控数据
    const socket = io('ws://localhost:8000/ws/monitor');

    socket.on('system_metrics', (metrics: SystemMetrics) => {
      setSystemMetrics(metrics);
    });

    socket.on('detection_metrics', (metrics: DetectionMetrics) => {
      setDetectionMetrics(metrics);
    });

    return () => {
      socket.disconnect();
    };
  }, []);

  return (
    <div className="monitor-page">
      <Row gutter={[16, 16]}>
        {/* 系统性能指标 */}
        <Col xs={24} md={12}>
          <Card title="系统性能" bordered={false}>
            <SystemPerformancePanel metrics={systemMetrics} />
          </Card>
        </Col>

        {/* 检测引擎指标 */}
        <Col xs={24} md={12}>
          <Card title="检测引擎" bordered={false}>
            <DetectionEnginePanel metrics={detectionMetrics} />
          </Card>
        </Col>

        {/* API请求监控 */}
        <Col span={24}>
          <Card title="API请求监控" bordered={false}>
            <ApiMonitoringPanel />
          </Card>
        </Col>

        {/* 实时告警 */}
        <Col span={24}>
          <Card title="实时告警" bordered={false}>
            <AlertStream />
          </Card>
        </Col>
      </Row>
    </div>
  );
}
```

#### 4.4.2 系统性能面板

```tsx
// components/Monitor/SystemPerformancePanel.tsx
function SystemPerformancePanel({ metrics }: { metrics: SystemMetrics | null }) {
  if (!metrics) {
    return <Skeleton active />;
  }

  return (
    <div className="system-performance-panel">
      <Row gutter={[16, 16]}>
        <Col span={8}>
          <Statistic
            title="CPU使用率"
            value={metrics.cpu_usage}
            precision={1}
            suffix="%"
            valueStyle={{
              color: metrics.cpu_usage > 80 ? '#ff4d4f' : '#52c41a'
            }}
          />
          <Progress
            percent={metrics.cpu_usage}
            strokeColor={metrics.cpu_usage > 80 ? '#ff4d4f' : '#52c41a'}
            showInfo={false}
          />
        </Col>

        <Col span={8}>
          <Statistic
            title="内存使用率"
            value={metrics.memory_usage}
            precision={1}
            suffix="%"
            valueStyle={{
              color: metrics.memory_usage > 80 ? '#ff4d4f' : '#52c41a'
            }}
          />
          <Progress
            percent={metrics.memory_usage}
            strokeColor={metrics.memory_usage > 80 ? '#ff4d4f' : '#52c41a'}
            showInfo={false}
          />
        </Col>

        <Col span={8}>
          <Statistic
            title="磁盘使用率"
            value={metrics.disk_usage}
            precision={1}
            suffix="%"
            valueStyle={{
              color: metrics.disk_usage > 80 ? '#ff4d4f' : '#52c41a'
            }}
          />
          <Progress
            percent={metrics.disk_usage}
            strokeColor={metrics.disk_usage > 80 ? '#ff4d4f' : '#52c41a'}
            showInfo={false}
          />
        </Col>
      </Row>

      <Divider />

      {/* QPS监控 */}
      <Row gutter={16}>
        <Col span={12}>
          <Card title="实时QPS" size="small">
            <Statistic
              value={metrics.current_qps}
              suffix="次/秒"
              valueStyle={{color: '#1890ff'}}
            />
            <TrendIndicator
              current={metrics.current_qps}
              previous={metrics.previous_qps}
            />
          </Card>
        </Col>

        <Col span={12}>
          <Card title="平均响应时间" size="small">
            <Statistic
              value={metrics.avg_response_time}
              suffix="ms"
              precision={2}
              valueStyle={{
                color: metrics.avg_response_time < 50 ? '#52c41a' : '#ff4d4f'
              }}
            />
            <TrendIndicator
              current={metrics.avg_response_time}
              previous={metrics.previous_response_time}
              inverse
            />
          </Card>
        </Col>
      </Row>
    </div>
  );
}
```

---

## 5. 数据交互流程

### 5.1 API调用流程

```typescript
// services/api.ts - API服务封装
import axios from 'axios';
import { message } from 'antd';

const apiClient = axios.create({
  baseURL: process.env.REACT_APP_API_BASE_URL || 'http://localhost:8000/api/v1',
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// 请求拦截器
apiClient.interceptors.request.use(
  (config) => {
    // 添加认证token
    const token = localStorage.getItem('auth_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }

    // 添加请求ID
    config.headers['X-Request-ID'] = generateRequestId();

    // 添加时间戳
    config.headers['X-Timestamp'] = Date.now().toString();

    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// 响应拦截器
apiClient.interceptors.response.use(
  (response) => {
    return response.data;
  },
  (error) => {
    if (error.response) {
      switch (error.response.status) {
        case 401:
          message.error('未授权,请重新登录');
          // 跳转到登录页
          window.location.href = '/login';
          break;
        case 403:
          message.error('没有权限访问此资源');
          break;
        case 404:
          message.error('请求的资源不存在');
          break;
        case 429:
          message.error('请求过于频繁,请稍后重试');
          break;
        case 500:
          message.error('服务器内部错误');
          break;
        default:
          message.error(error.response.data?.message || '请求失败');
      }
    } else if (error.request) {
      message.error('网络错误,请检查您的网络连接');
    } else {
      message.error('请求配置错误');
    }

    return Promise.reject(error);
  }
);

// API接口定义
export const detectionApi = {
  // 实时检测
  detect: (params: DetectionRequest): Promise<DetectionResponse> => {
    return apiClient.post('/detection/detect', params);
  },

  // 批量检测
  batchDetect: (formData: FormData): Promise<BatchDetectionResponse> => {
    return apiClient.post('/detection/batch', formData, {
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    });
  },

  // 获取检测结果
  getResult: (requestId: string): Promise<DetectionResult> => {
    return apiClient.get(`/detection/result/${requestId}`);
  },

  // 获取统计信息
  getStatistics: (params: StatisticsQuery): Promise<StatisticsResponse> => {
    return apiClient.get('/statistics', {params});
  },

  // 获取趋势数据
  getTrendData: (params: TrendQuery): Promise<TrendResponse> => {
    return apiClient.get('/statistics/trend', {params});
  }
};
```

### 5.2 状态管理

```typescript
// store/slices/detectionSlice.ts
import { createSlice, createAsyncThunk } from '@reduxjs/toolkit';

interface DetectionState {
  currentResult: DetectionResult | null;
  isDetecting: boolean;
  error: string | null;
  history: DetectionResult[];
}

const initialState: DetectionState = {
  currentResult: null,
  isDetecting: false,
  error: null,
  history: []
};

export const detectAsync = createAsyncThunk(
  'detection/detect',
  async (params: DetectionRequest) => {
    const response = await detectionApi.detect(params);
    return response;
  }
);

const detectionSlice = createSlice({
  name: 'detection',
  initialState,
  reducers: {
    clearResult: (state) => {
      state.currentResult = null;
      state.error = null;
    },
    clearHistory: (state) => {
      state.history = [];
    }
  },
  extraReducers: (builder) => {
    builder
      .addCase(detectAsync.pending, (state) => {
        state.isDetecting = true;
        state.error = null;
      })
      .addCase(detectAsync.fulfilled, (state, action) => {
        state.isDetecting = false;
        state.currentResult = action.payload;
        state.history.unshift(action.payload);
        // 只保留最近100条记录
        if (state.history.length > 100) {
          state.history = state.history.slice(0, 100);
        }
      })
      .addCase(detectAsync.rejected, (state, action) => {
        state.isDetecting = false;
        state.error = action.error.message || '检测失败';
      });
  }
});

export const { clearResult, clearHistory } = detectionSlice.actions;
export default detectionSlice.reducer;
```

---

## 6. 状态管理设计

### 6.1 全局状态结构

```typescript
// store/index.ts
interface RootState {
  detection: DetectionState;
  user: UserState;
  monitor: MonitorState;
  settings: SettingsState;
}

// 状态初始化
const store = configureStore({
  reducer: {
    detection: detectionReducer,
    user: userReducer,
    monitor: monitorReducer,
    settings: settingsReducer
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: false
    }).concat(logger)
});
```

### 6.2 React Query数据缓存

```typescript
// hooks/useStatistics.ts
import { useQuery } from '@tanstack/react-query';
import { detectionApi } from '@/services/api';

export function useGetStatisticsQuery(params: StatisticsQuery) {
  return useQuery({
    queryKey: ['statistics', params],
    queryFn: () => detectionApi.getStatistics(params),
    refetchInterval: 5000, // 每5秒自动刷新
    staleTime: 1000
  });
}
```

---

## 7. 用户体验设计

### 7.1 加载状态设计

```tsx
// components/Loading/LoadingOverlay.tsx
interface LoadingOverlayProps {
  loading: boolean;
  tip?: string;
}

function LoadingOverlay({ loading, tip = '加载中...' }: LoadingOverlayProps) {
  return (
    <Spin spinning={loading} tip={tip} size="large">
      <div style={{minHeight: 200}} />
    </Spin>
  );
}
```

### 7.2 错误边界

```tsx
// components/ErrorBoundary.tsx
interface ErrorBoundaryState {
  hasError: boolean;
  error: Error | null;
}

class ErrorBoundary extends React.Component<Props, ErrorBoundaryState> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, error: null };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // 上报错误到监控服务
    reportErrorToService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <Result
          status="error"
          title="页面加载失败"
          subTitle="抱歉,页面遇到了一些问题,请稍后重试"
          extra={[
            <Button type="primary" onClick={() => window.location.reload()}>
              刷新页面
            </Button>,
            <Button onClick={() => this.setState({hasError: false})}>
              重试
            </Button>
          ]}
        />
      );
    }

    return this.props.children;
  }
}
```

---

## 8. 响应式设计

### 8.1 断点配置

```scss
// styles/breakpoints.scss
$break-xs: 480px;
$break-sm: 576px;
$break-md: 768px;
$break-lg: 992px;
$break-xl: 1200px;
$break-xxl: 1600px;

// 响应式Mixin
@mixin respond-to($breakpoint) {
  @if $breakpoint == xs {
    @media (max-width: $break-xs) { @content; }
  } @else if $breakpoint == sm {
    @media (max-width: $break-sm) { @content; }
  } @else if $breakpoint == md {
    @media (max-width: $break-md) { @content; }
  } @else if $breakpoint == lg {
    @media (max-width: $break-lg) { @content; }
  } @else if $breakpoint == xl {
    @media (max-width: $break-xl) { @content; }
  }
}
```

### 8.2 响应式布局示例

```tsx
// 响应式卡片布局
function ResponsiveCardGrid() {
  return (
    <Row gutter={[16, 16]}>
      <Col
        xs={24}      // 移动端: 1列
        sm={12}      // 平板: 2列
        md={8}       // 桌面: 3列
        lg={6}       // 大屏: 4列
        xl={4}       // 超大屏: 6列
      >
        <Card>...</Card>
      </Col>
    </Row>
  );
}
```

---

## 9. 性能优化策略

### 9.1 代码分割

```typescript
// 路由级别代码分割
import { lazy, Suspense } from 'react';

const DashboardPage = lazy(() => import('./pages/Dashboard'));
const RealtimeDetectionPage = lazy(() => import('./pages/Detection/Realtime'));
const BatchDetectionPage = lazy(() => import('./pages/Detection/Batch'));

function App() {
  return (
    <Suspense fallback={<LoadingPage />}>
      <Routes>
        <Route path="/dashboard" element={<DashboardPage />} />
        <Route path="/detection/realtime" element={<RealtimeDetectionPage />} />
        <Route path="/detection/batch" element={<BatchDetectionPage />} />
      </Routes>
    </Suspense>
  );
}
```

### 9.2 虚拟列表优化

```tsx
// components/VirtualizedList.tsx
import { List } from 'react-virtualized';

function VirtualizedDetectionList({ items }: { items: DetectionResult[] }) {
  const rowRenderer = ({ index, key, style }: ListRowProps) => {
    const item = items[index];
    return (
      <div key={key} style={style}>
        <DetectionResultCard result={item} />
      </div>
    );
  };

  return (
    <List
      width={800}
      height={600}
      rowCount={items.length}
      rowHeight={120}
      rowRenderer={rowRenderer}
    />
  );
}
```

### 9.3 防抖与节流

```typescript
// hooks/useDebounce.ts
function useDebounce<T>(value: T, delay: number = 300): T {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(timer);
    };
  }, [value, delay]);

  return debouncedValue;
}

// 使用示例
function SearchInput() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  useEffect(() => {
    if (debouncedSearchTerm) {
      performSearch(debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);

  return (
    <Input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="搜索..."
    />
  );
}
```

---

## 附录

### A. 事件处理规范

```typescript
// 统一事件处理
const handleEvent = (event: React.MouseEvent | React.ChangeEvent) => {
  event.preventDefault();
  // 事件处理逻辑
};

// 错误处理
try {
  await riskyOperation();
} catch (error) {
  handleError(error);
}
```

### B. 表单验证规范

```typescript
// 表单验证规则
const validationRules = {
  userInput: [
    { required: true, message: '请输入检测内容' },
    { min: 10, message: '内容长度不能少于10个字符' },
    { max: 10000, message: '内容长度不能超过10000个字符' }
  ]
};
```

### C. WebSocket重连机制

```typescript
// WebSocket重连配置
const socketOptions: SocketOptions = {
  reconnection: true,
  reconnectionAttempts: 5,
  reconnectionDelay: 1000,
  reconnectionDelayMax: 5000,
  timeout: 10000
};
```

---

## 10. 详细用户交互流程

### 10.1 实时检测完整交互流程

#### 流程图

```
用户打开实时检测页面
    ↓
页面初始化
    ├─→ 建立WebSocket连接
    │   ├─→ 成功 → 显示"已连接"状态 ✅
    │   └─→ 失败 → 显示重连按钮 ⚠️
    ├─→ 加载用户历史配置
    └─→ 初始化检测选项
    ↓
用户输入待检测文本
    ↓
前端实时验证
    ├─→ 长度检查 (10-10000字符)
    ├─→ 格式检查 (UTF-8编码)
    └─→ 内容预检查 (敏感词过滤)
    ↓
用户配置检测选项
    ├─→ 选择检测模型 (标准/高级)
    ├─→ 启用上下文分析 (是/否)
    └─→ 启用深度检测 (是/否)
    ↓
点击"开始检测"按钮
    ↓
显示检测中状态
    ├─→ 禁用输入框和按钮
    ├─→ 显示加载动画
    └─→ 显示"正在进行安全检测..."提示
    ↓
通过WebSocket发送检测请求
    ├─→ 请求格式:
    │   {
    │     "user_input": "待检测文本",
    │     "options": {
    │       "model": "standard",
    │       "context_analysis": true,
    │       "deep_detection": false
    │     },
    │     "metadata": {
    │       "timestamp": 1234567890,
    │       "request_id": "req_abc123"
    │     }
    │   }
    ↓
后端7层检测流程
    ├─→ 输入层: 接收和预处理
    ├─→ 预处理层: 清洗和标准化
    ├─→ 检测层: 多模态检测
    │   ├─→ 静态检测 (关键词匹配)
    │   ├─→ 语义分析 (向量相似度)
    │   ├─→ 行为分析 (异常模式)
    │   └─→ 上下文分析 (对话历史)
    ├─→ 评估层: 风险评分
    ├─→ 决策层: 处理策略
    └─→ 输出层: 生成结果
    ↓
前端接收实时检测结果
    ├─→ 更新检测结果面板
    ├─→ 显示风险评分
    ├─→ 显示风险等级标签
    ├─→ 显示威胁类别
    ├─→ 显示检测详情
    └─→ 显示处理建议
    ↓
根据风险等级显示不同反馈
    ├─→ 严重风险 (0.8-1.0)
    │   ├─→ 红色警告动画
    │   ├─→ 弹窗提示
    │   ├─→ 显示拦截建议
    │   └─→ 记录到威胁库
    ├─→ 高风险 (0.5-0.8)
    │   ├─→ 橙色警告提示
    │   ├─→ 显示详细分析
    │   └─→ 建议人工审核
    ├─→ 中风险 (0.3-0.5)
    │   ├─→ 黄色提示
    │   ├─→ 显示警告信息
    │   └─→ 记录日志
    └─→ 低风险 (0.0-0.3)
        ├─→ 绿色成功提示
        └─→ 显示"内容安全"
    ↓
用户查看检测详情
    ├─→ 查看7层检测流程
    ├─→ 查看匹配的模式
    ├─→ 查看攻击向量分析
    └─→ 查看置信度评分
    ↓
用户执行后续操作
    ├─→ 导出检测报告 (PDF/JSON)
    ├─→ 添加到测试用例库
    ├─→ 重新检测
    └─→ 返回修改输入
```

#### 交互细节

**步骤1: 页面初始化**
```typescript
useEffect(() => {
  // 1. 建立WebSocket连接
  initWebSocketConnection();

  // 2. 加载用户配置
  loadUserPreferences();

  // 3. 恢复上次会话
  restoreLastSession();

  // 4. 注册事件监听
  registerEventListeners();
}, []);

// WebSocket连接初始化
const initWebSocketConnection = () => {
  const socket = io('ws://localhost:8000/ws/detect', {
    auth: {
      token: localStorage.getItem('auth_token')
    },
    reconnection: true,
    reconnectionAttempts: 5,
    reconnectionDelay: 1000
  });

  socket.on('connect', () => {
    updateConnectionStatus('connected');
    message.success('实时检测服务已连接', 2);
  });

  socket.on('disconnect', () => {
    updateConnectionStatus('disconnected');
    message.warning('连接已断开,正在重连...', 3);
  });

  socket.on('reconnect', (attemptNumber) => {
    updateConnectionStatus('connected');
    message.success(`重连成功 (第${attemptNumber}次尝试)`, 2);
  });

  setSocket(socket);
};
```

**步骤2: 输入验证**
```typescript
const validateInput = (input: string): ValidationResult => {
  // 长度验证
  if (input.length < 10) {
    return {
      valid: false,
      error: '输入内容不能少于10个字符',
      field: 'user_input'
    };
  }

  if (input.length > 10000) {
    return {
      valid: false,
      error: '输入内容不能超过10000个字符',
      field: 'user_input'
    };
  }

  // 编码验证
  try {
    encodeURIComponent(input);
  } catch {
    return {
      valid: false,
      error: '输入包含非法字符',
      field: 'user_input'
    };
  }

  // 敏感词预检查
  const sensitiveWords = ['炸弹', '毒药', '攻击'];
  const hasSensitiveWord = sensitiveWords.some(word =>
    input.toLowerCase().includes(word)
  );

  if (hasSensitiveWord) {
    return {
      valid: true,
      warning: '输入包含敏感词汇,将进行深度检测',
      field: 'user_input'
    };
  }

  return { valid: true };
};
```

**步骤3: 发送检测请求**
```typescript
const handleStartDetection = async () => {
  // 1. 验证输入
  const validation = validateInput(userInput);
  if (!validation.valid) {
    message.error(validation.error);
    return;
  }

  if (validation.warning) {
    message.warning(validation.warning);
  }

  // 2. 更新UI状态
  setIsDetecting(true);
  setDetectionProgress(0);

  // 3. 构造请求对象
  const request: DetectionRequest = {
    user_input: userInput,
    model_response: '', // 可选
    conversation_history: contextAnalysis ? conversationHistory : [],
    metadata: {
      user_id: currentUser.id,
      session_id: sessionId,
      timestamp: Date.now(),
      request_id: generateRequestId(),
      detection_options: {
        model: selectedModel,
        context_analysis: contextAnalysis,
        deep_detection: deepDetection
      }
    }
  };

  // 4. 通过WebSocket发送
  socket.emit('start_detection', request);

  // 5. 显示进度
  simulateProgress();
};
```

**步骤4: 接收和展示结果**
```typescript
// 监听检测结果
socket.on('detection_progress', (progress: DetectionProgress) => {
  // 更新进度条
  setDetectionProgress(progress.percent);

  // 显示当前检测阶段
  setCurrentStage(progress.stage);

  // 实时更新日志
  appendDetectionLog(progress.message);
});

socket.on('detection_complete', (result: DetectionResult) => {
  // 隐藏加载状态
  setIsDetecting(false);

  // 保存结果
  setDetectionResult(result);

  // 添加到历史记录
  addToHistory(result);

  // 根据风险等级显示不同提示
  showRiskNotification(result);

  // 触发完成动画
  playCompletionAnimation(result.risk_level);
});

// 风险通知
const showRiskNotification = (result: DetectionResult) => {
  const notifications = {
    critical: () => {
      notification.error({
        message: '检测到严重安全威胁!',
        description: `风险评分: ${(result.risk_score * 100).toFixed(1)}%`,
        duration: 0, // 不自动关闭
        key: result.request_id,
        btn: (
          <Space>
            <Button type="primary" onClick={() => viewDetail(result)}>
              查看详情
            </Button>
            <Button onClick={() => notification.close(result.request_id)}>
              关闭
            </Button>
          </Space>
        )
      });
    },
    high: () => {
      notification.warning({
        message: '检测到高风险内容',
        description: `威胁类别: ${result.threat_category}`,
        duration: 8
      });
    },
    medium: () => {
      message.info('检测到中等风险,请注意查看详情', 5);
    },
    low: () => {
      message.success('内容安全,检测通过', 3);
    }
  };

  notifications[result.risk_level]?.();
};
```

**步骤5: 结果可视化**
```typescript
// 检测结果面板组件
const DetectionResultPanel: React.FC<Props> = ({ result }) => {
  return (
    <div className="detection-result-panel">
      {/* 风险评分可视化 */}
      <div className="risk-score-visualization">
        <RiskScoreGauge
          score={result.risk_score}
          level={result.risk_level}
          animated={true}
        />
      </div>

      {/* 7层检测流程可视化 */}
      <div className="detection-layers-visualization">
        <Title level={5}>7层检测流程</Title>
        <Steps
          current={7}
          items={[
            {
              title: '输入层',
              description: '数据接收与预处理',
              icon: <InputOutlined />,
              status: 'finish'
            },
            {
              title: '预处理层',
              description: '清洗与标准化',
              icon: <ClearOutlined />,
              status: 'finish'
            },
            {
              title: '检测层',
              description: '多模态检测',
              icon: <ScanOutlined />,
              status: 'finish',
              subItems: [
                { title: '静态检测', score: 0.85 },
                { title: '语义分析', score: 0.72 },
                { title: '行为分析', score: 0.68 },
                { title: '上下文分析', score: 0.90 }
              ]
            },
            {
              title: '评估层',
              description: `风险评分: ${result.risk_score.toFixed(3)}`,
              icon: <CalculatorOutlined />,
              status: 'finish'
            },
            {
              title: '决策层',
              description: result.recommendation === 'block' ? '拦截' : '通过',
              icon: result.recommendation === 'block' ?
                <StopOutlined /> : <CheckOutlined />,
              status: 'finish'
            },
            {
              title: '输出层',
              description: '生成报告',
              icon: <FileTextOutlined />,
              status: 'finish'
            },
            {
              title: '存储层',
              description: '记录日志',
              icon: <DatabaseOutlined />,
              status: 'finish'
            }
          ]}
        />
      </div>

      {/* 威胁分析详情 */}
      <div className="threat-analysis-details">
        <Collapse
          items={[
            {
              key: '1',
              label: '威胁类别分析',
              children: (
                <ThreatCategoryAnalysis
                  category={result.threat_category}
                  attackVector={result.detection_details.attack_vector}
                />
              )
            },
            {
              key: '2',
              label: '匹配的模式',
              children: (
                <MatchedPatternsList
                  patterns={result.detection_details.matched_patterns}
                />
              )
            },
            {
              key: '3',
              label: '置信度分析',
              children: (
                <ConfidenceAnalysis
                  confidence={result.detection_details.confidence}
                  breakdown={result.detection_details.confidence_breakdown}
                />
              )
            }
          ]}
        />
      </div>

      {/* 处理建议 */}
      <div className="recommendation-section">
        <Alert
          message="处理建议"
          description={
            result.recommendation === 'block' ? (
              <Space direction="vertical">
                <Text strong>⛔ 建议拦截此内容</Text>
                <Text>该内容包含严重的{result.threat_category}威胁</Text>
                <Text>置信度: {(result.detection_details.confidence * 100).toFixed(1)}%</Text>
              </Space>
            ) : (
              <Space direction="vertical">
                <Text strong>✅ 内容安全,可以放行</Text>
                <Text>风险评分在可接受范围内</Text>
              </Space>
            )
          }
          type={result.recommendation === 'block' ? 'error' : 'success'}
          showIcon
        />
      </div>

      {/* 操作按钮 */}
      <div className="action-buttons">
        <Space>
          <Button
            type="primary"
            icon={<ExportOutlined />}
            onClick={() => exportReport(result, 'pdf')}
          >
            导出PDF报告
          </Button>
          <Button
            icon={<FileAddOutlined />}
            onClick={() => addToTestCase(result)}
          >
            添加到测试用例
          </Button>
          <Button
            icon={<ShareAltOutlined />}
            onClick={() => shareResult(result)}
          >
            分享结果
          </Button>
          <Button
            icon={<RedoOutlined />}
            onClick={() => redoDetection()}
          >
            重新检测
          </Button>
        </Space>
      </div>
    </div>
  );
};
```

### 10.2 批量检测交互流程

#### 流程图

```
用户进入批量检测页面
    ↓
上传文件
    ├─→ 点击上传区域
    │   └─→ 文件选择对话框
    ├─→ 拖拽文件到上传区
    └─→ 批量选择文件
    ↓
文件验证
    ├─→ 格式检查 (.txt, .json, .csv)
    ├─→ 大小检查 (≤ 10MB)
    ├─→ 内容格式验证
    └─→ 显示文件列表
    ↓
配置检测参数
    ├─→ 选择检测模型
    ├─→ 设置并发数 (1-10)
    ├─→ 设置超时时间
    └─→ 选择输出格式
    ↓
点击"开始批量检测"
    ↓
显示上传进度
    ├─→ 上传文件到服务器
    └─→ 进度条显示上传百分比
    ↓
服务器处理
    ├─→ 解析文件内容
    ├─→ 分批检测
    ├─→ 并发处理请求
    └─→ 实时返回进度
    ↓
前端显示检测进度
    ├─→ 整体进度条
    ├─→ 当前处理文件
    ├─→ 已完成/总数
    └─→ 预计剩余时间
    ↓
检测完成
    ├─→ 显示汇总统计
    │   ├─→ 总文件数
    │   ├─→ 检测通过数
    │   ├─→ 威胁拦截数
    │   └─→ 检测失败数
    └─→ 显示结果表格
    ↓
结果筛选和排序
    ├─→ 按风险等级筛选
    ├─→ 按威胁类别筛选
    ├─→ 按处理时间排序
    └─→ 搜索功能
    ↓
批量操作
    ├─→ 导出全部结果
    ├─→ 导出筛选结果
    ├─→ 导出威胁报告
    ├─→ 批量删除
    └─→ 重新检测失败项
```

#### 交互实现

**文件上传组件**
```typescript
const FileUploadZone: React.FC = () => {
  const [fileList, setFileList] = useState<UploadFile[]>([]);
  const [uploadProgress, setUploadProgress] = useState(0);

  const uploadProps: UploadProps = {
    name: 'files',
    multiple: true,
    accept: '.txt,.json,.csv',
    action: '/api/v1/detection/batch/upload',
    beforeUpload: (file: File) => {
      // 验证文件格式
      const validFormats = ['text/plain', 'application/json', 'text/csv'];
      if (!validFormats.includes(file.type)) {
        message.error(`不支持的文件格式: ${file.type}`);
        return Upload.LIST_IGNORE;
      }

      // 验证文件大小
      const isLt10M = file.size / 1024 / 1024 < 10;
      if (!isLt10M) {
        message.error('文件大小不能超过10MB');
        return Upload.LIST_IGNORE;
      }

      return true;
    },
    onChange: (info: UploadChangeParam) => {
      setFileList(info.fileList);

      // 计算上传进度
      if (info.event) {
        setUploadProgress(info.event.percent);
      }
    },
    onDrop: (e: React.DragEvent) => {
      console.log('Dropped files', e.dataTransfer.files);
    },
    progress: {
      strokeColor: {
        '0%': '#108ee9',
        '100%': '#87d068'
      },
      strokeWidth: 3,
      format: (percent) => percent && `${percent}%`
    }
  };

  return (
    <div className="file-upload-zone">
      <Dragger {...uploadProps} className="upload-dragger">
        <p className="ant-upload-drag-icon">
          <InboxOutlined />
        </p>
        <p className="ant-upload-text">
          点击或拖拽文件到此区域上传
        </p>
        <p className="ant-upload-hint">
          支持批量上传 .txt, .json, .csv 格式文件<br />
          单个文件不超过10MB,最多支持50个文件
        </p>
      </Dragger>

      {/* 上传进度 */}
      {uploadProgress > 0 && uploadProgress < 100 && (
        <Progress
          percent={uploadProgress}
          status="active"
          strokeColor="#108ee9"
        />
      )}

      {/* 文件列表 */}
      {fileList.length > 0 && (
        <div className="file-list">
          <Divider>已选择的文件</Divider>
          <List
            dataSource={fileList}
            renderItem={(file) => (
              <List.Item>
                <List.Item.Meta
                  avatar={
                    file.status === 'done' ?
                      <FileTextOutlined style={{color: '#52c41a'}} /> :
                      <LoadingOutlined />
                  }
                  title={file.name}
                  description={
                    <Space>
                      <Text>{(file.size / 1024).toFixed(2)} KB</Text>
                      {file.percent && <Progress
                        percent={file.percent}
                        size="small"
                        style={{width: 100}}
                      />}
                    </Space>
                  }
                />
                <Button
                  type="link"
                  danger
                  icon={<DeleteOutlined />}
                  onClick={() => removeFile(file.uid)}
                >
                  删除
                </Button>
              </List.Item>
            )}
          />
        </div>
      )}
    </div>
  );
};
```

**批量检测进度追踪**
```typescript
const BatchDetectionProgress: React.FC = () => {
  const [progress, setProgress] = useState<BatchProgress>({
    total: 0,
    completed: 0,
    failed: 0,
    current: '',
    percent: 0,
    estimatedTime: 0
  });

  const [results, setResults] = useState<BatchDetectionResult[]>([]);

  // 通过WebSocket监听进度
  useEffect(() => {
    const socket = io('ws://localhost:8000/ws/batch-detect');

    socket.on('batch_progress', (data: BatchProgress) => {
      setProgress(data);
    });

    socket.on('batch_result', (result: BatchDetectionResult) => {
      setResults(prev => [...prev, result]);
    });

    socket.on('batch_complete', (summary: BatchSummary) => {
      message.success(
        `批量检测完成! 成功: ${summary.success}, 失败: ${summary.failed}`
      );
    });

    return () => socket.disconnect();
  }, []);

  return (
    <div className="batch-detection-progress">
      {/* 整体进度 */}
      <Card title="检测进度" bordered={false}>
        <Progress
          percent={progress.percent}
          status={progress.failed > 0 ? 'exception' : 'active'}
          strokeColor={
            progress.failed > 0 ? '#ff4d4f' :
            progress.percent === 100 ? '#52c41a' : '#108ee9'
          }
        />

        <Row gutter={16} style={{marginTop: 16}}>
          <Col span={6}>
            <Statistic
              title="总文件数"
              value={progress.total}
              prefix={<FileOutlined />}
            />
          </Col>
          <Col span={6}>
            <Statistic
              title="已完成"
              value={progress.completed}
              prefix={<CheckCircleOutlined />}
              valueStyle={{color: '#52c41a'}}
            />
          </Col>
          <Col span={6}>
            <Statistic
              title="失败"
              value={progress.failed}
              prefix={<CloseCircleOutlined />}
              valueStyle={{color: '#ff4d4f'}}
            />
          </Col>
          <Col span={6}>
            <Statistic
              title="预计剩余"
              value={progress.estimatedTime}
              suffix="秒"
              prefix={<ClockCircleOutlined />}
            />
          </Col>
        </Row>

        {/* 当前处理文件 */}
        {progress.current && (
          <Alert
            message={`正在处理: ${progress.current}`}
            type="info"
            showIcon
            style={{marginTop: 16}}
          />
        )}
      </Card>

      {/* 实时结果 */}
      {results.length > 0 && (
        <Card title="实时结果" bordered={false} style={{marginTop: 16}}>
          <Table
            dataSource={results}
            columns={batchResultColumns}
            rowKey="request_id"
            pagination={false}
            scroll={{y: 400}}
          />
        </Card>
      )}
    </div>
  );
};
```

### 10.3 仪表盘数据流转

#### 数据流图

```
页面加载
    ↓
发起多个并行API请求
    ├─→ GET /api/v1/statistics (统计数据)
    ├─→ GET /api/v1/statistics/trend (趋势数据)
    ├─→ GET /api/v1/statistics/threats (威胁分布)
    └─→ GET /api/v1/statistics/top-threats (TOP威胁)
    ↓
数据到达前端
    ├─→ 存入React Query缓存
    ├─→ 更新组件状态
    └─→ 触发图表渲染
    ↓
建立WebSocket连接
    ├─→ 订阅实时统计数据
    └─→ 订阅告警信息
    ↓
实时数据更新
    ├─→ 每5秒自动刷新统计数据
    ├─→ WebSocket推送实时更新
    └─→ 图表动态刷新
    ↓
用户交互
    ├─→ 切换时间范围
    │   └─→ 重新请求趋势数据
    ├─→ 筛选威胁类型
    │   └─→ 更新图表显示
    └─→ 导出报告
        └─→ 生成PDF/Excel
```

#### 数据获取实现

```typescript
// 使用React Query管理数据
const DashboardPage: React.FC = () => {
  // 1. 获取统计数据
  const {
    data: statistics,
    isLoading: statsLoading,
    refetch: refetchStats
  } = useQuery({
    queryKey: ['statistics'],
    queryFn: async () => {
      const response = await axios.get('/api/v1/statistics');
      return response.data;
    },
    refetchInterval: 5000, // 每5秒刷新
    staleTime: 1000
  });

  // 2. 获取趋势数据
  const {
    data: trendData,
    isLoading: trendLoading
  } = useQuery({
    queryKey: ['trendData', timeRange],
    queryFn: async () => {
      const response = await axios.get('/api/v1/statistics/trend', {
        params: {
          start_date: timeRange.start,
          end_date: timeRange.end,
          granularity: 'hour'
        }
      });
      return response.data;
    }
  });

  // 3. 获取威胁分布
  const {
    data: threatDistribution,
    isLoading: distributionLoading
  } = useQuery({
    queryKey: ['threatDistribution'],
    queryFn: async () => {
      const response = await axios.get('/api/v1/statistics/threats');
      return response.data;
    }
  });

  // 4. 实时订阅
  useEffect(() => {
    const socket = io('ws://localhost:8000/ws/dashboard');

    socket.on('statistics_update', (newStats: Statistics) => {
      // 直接更新Query缓存
      queryClient.setQueryData(['statistics'], newStats);
    });

    socket.on('new_threat_alert', (alert: ThreatAlert) => {
      // 显示实时告警
      notification.warning({
        message: '新威胁告警',
        description: alert.message,
        duration: 5
      });

      // 添加到告警列表
      setAlerts(prev => [alert, ...prev]);
    });

    return () => socket.disconnect();
  }, []);

  // 5. 处理时间范围切换
  const handleTimeRangeChange = (range: TimeRange) => {
    setTimeRange(range);
    // React Query会自动重新获取
  };

  // 6. 导出报告
  const handleExportReport = async () => {
    try {
      const response = await axios.post('/api/v1/statistics/export', {
        format: 'pdf',
        time_range: timeRange
      }, {
        responseType: 'blob'
      });

      // 下载文件
      const url = window.URL.createObjectURL(new Blob([response.data]));
      const link = document.createElement('a');
      link.href = url;
      link.setAttribute('download', `security_report_${Date.now()}.pdf`);
      document.body.appendChild(link);
      link.click();
      link.remove();

      message.success('报告导出成功');
    } catch (error) {
      message.error('报告导出失败');
    }
  };

  return (
    <div className="dashboard-page">
      {/* 时间范围选择器 */}
      <Card bordered={false} style={{marginBottom: 16}}>
        <Space>
          <Text>时间范围:</Text>
          <Radio.Group value={timeRange} onChange={(e) => handleTimeRangeChange(e.target.value)}>
            <Radio.Button value="1h">最近1小时</Radio.Button>
            <Radio.Button value="24h">最近24小时</Radio.Button>
            <Radio.Button value="7d">最近7天</Radio.Button>
            <Radio.Button value="30d">最近30天</Radio.Button>
          </Radio.Group>
          <Divider type="vertical" />
          <Button
            icon={<ReloadOutlined />}
            onClick={() => refetchStats()}
            loading={statsLoading}
          >
            刷新
          </Button>
          <Button
            icon={<ExportOutlined />}
            onClick={handleExportReport}
          >
            导出报告
          </Button>
        </Space>
      </Card>

      {/* 统计卡片 */}
      <Row gutter={[16, 16]}>
        <Col xs={24} sm={12} md={6}>
          <StatisticCard
            title="总检测次数"
            value={statistics?.total_detections || 0}
            prefix={<SecurityScanOutlined />}
            suffix="次"
            loading={statsLoading}
            trend={{
              current: statistics?.detections_24h || 0,
              previous: statistics?.detections_previous_24h || 0
            }}
          />
        </Col>

        <Col xs={24} sm={12} md={6}>
          <StatisticCard
            title="威胁拦截"
            value={statistics?.blocked_threats || 0}
            prefix={<StopOutlined />}
            suffix="次"
            valueStyle={{color: '#ff4d4f'}}
            loading={statsLoading}
            trend={{
              current: statistics?.threats_24h || 0,
              previous: statistics?.threats_previous_24h || 0
            }}
          />
        </Col>

        <Col xs={24} sm={12} md={6}>
          <StatisticCard
            title="平均响应时间"
            value={statistics?.avg_response_time || 0}
            prefix={<ClockCircleOutlined />}
            suffix="ms"
            precision={2}
            loading={statsLoading}
          />
        </Col>

        <Col xs={24} sm={12} md={6}>
          <StatisticCard
            title="检测准确率"
            value={statistics?.accuracy || 0}
            prefix={<CheckCircleOutlined />}
            suffix="%"
            precision={2}
            valueStyle={{color: '#52c41a'}}
            loading={statsLoading}
          />
        </Col>
      </Row>

      {/* 图表区域 */}
      <Row gutter={[16, 16]} style={{marginTop: 16}}>
        <Col xs={24} lg={16}>
          <Card title="检测趋势" bordered={false} loading={trendLoading}>
            <TrendChart data={trendData} />
          </Card>
        </Col>

        <Col xs={24} lg={8}>
          <Card title="威胁类型分布" bordered={false} loading={distributionLoading}>
            <ThreatDistributionChart data={threatDistribution} />
          </Card>
        </Col>
      </Row>
    </div>
  );
};
```

## 文档修订记录

| 版本 | 日期 | 修订人 | 修订内容 |
|------|------|--------|----------|
| v1.0 | 2025-12-26 | 前端团队 | 初始版本创建 |
| v1.1 | 2025-12-26 | 前端团队 | 增加详细交互流程和数据流转 |

---

**文档结束**
